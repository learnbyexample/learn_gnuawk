<!doctypehtml><html class="sidebar-visible no-js light"lang=en><head><meta charset=UTF-8><title>Regular Expressions - CLI text processing with GNU awk</title><meta content="text/html; charset=utf-8"http-equiv=Content-Type><meta content="Example based guide to mastering GNU awk"name=description><meta content=width=device-width,initial-scale=1 name=viewport><meta content=#ffffff name=theme-color><meta content="CLI text processing with GNU awk"property=og:title><meta content=website property=og:type><meta content="Example based guide to mastering GNU awk"property=og:description><meta content=https://learnbyexample.github.io/learn_gnuawk/ property=og:url><meta content=https://raw.githubusercontent.com/learnbyexample/learn_gnuawk/master/images/gawk_ls.png property=og:image><meta content=1280 property=og:image:width><meta content=720 property=og:image:height><meta content=summary_large_image property=twitter:card><meta content=@learn_byexample property=twitter:site><link href=favicon.svg rel=icon><link rel="shortcut icon"href=favicon.png><link href=css/variables.css rel=stylesheet><link href=css/general.css rel=stylesheet><link href=css/chrome.css rel=stylesheet><link href=FontAwesome/css/font-awesome.css rel=stylesheet><link href=fonts/fonts.css rel=stylesheet><link href=highlight.css rel=stylesheet><link href=tomorrow-night.css rel=stylesheet><link href=ayu-highlight.css rel=stylesheet><link href=style.css rel=stylesheet><body><script>var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";</script><script>try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }</script><script>var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');</script><script>var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);</script><nav aria-label="Table of contents"class=sidebar id=sidebar><div class=sidebar-scrollbox><ol class=chapter><li class="chapter-item expanded affix"><a href=cover.html>Cover</a><li class="chapter-item expanded affix"><a href=buy.html>Buy PDF/EPUB versions</a><li class="chapter-item expanded"><a href=preface.html><strong aria-hidden=true>1.</strong> Preface</a><li class="chapter-item expanded"><a href=installation-and-documentation.html><strong aria-hidden=true>2.</strong> Installation and Documentation</a><li class="chapter-item expanded"><a href=awk-introduction.html><strong aria-hidden=true>3.</strong> awk introduction</a><li class="chapter-item expanded"><a class=active href=regular-expressions.html><strong aria-hidden=true>4.</strong> Regular Expressions</a><li class="chapter-item expanded"><a href=field-separators.html><strong aria-hidden=true>5.</strong> Field separators</a><li class="chapter-item expanded"><a href=record-separators.html><strong aria-hidden=true>6.</strong> Record separators</a><li class="chapter-item expanded"><a href=in-place-file-editing.html><strong aria-hidden=true>7.</strong> In-place file editing</a><li class="chapter-item expanded"><a href=using-shell-variables.html><strong aria-hidden=true>8.</strong> Using shell variables</a><li class="chapter-item expanded"><a href=control-structures.html><strong aria-hidden=true>9.</strong> Control Structures</a><li class="chapter-item expanded"><a href=built-in-functions.html><strong aria-hidden=true>10.</strong> Built-in functions</a><li class="chapter-item expanded"><a href=multiple-file-input.html><strong aria-hidden=true>11.</strong> Multiple file input</a><li class="chapter-item expanded"><a href=processing-multiple-records.html><strong aria-hidden=true>12.</strong> Processing multiple records</a><li class="chapter-item expanded"><a href=two-file-processing.html><strong aria-hidden=true>13.</strong> Two file processing</a><li class="chapter-item expanded"><a href=dealing-with-duplicates.html><strong aria-hidden=true>14.</strong> Dealing with duplicates</a><li class="chapter-item expanded"><a href=awk-scripts.html><strong aria-hidden=true>15.</strong> awk scripts</a><li class="chapter-item expanded"><a href=gotchas-and-tips.html><strong aria-hidden=true>16.</strong> Gotchas and Tips</a><li class="chapter-item expanded"><a href=further-reading.html><strong aria-hidden=true>17.</strong> Further Reading</a><li class="chapter-item expanded"><a href=Exercise_solutions.html><strong aria-hidden=true>18.</strong> Exercise Solutions</a></li><br><hr><li class="chapter-item expanded"><i class="fa fa-github"id=git-repository-button></i><a href=https://github.com/learnbyexample/learn_gnuawk>   Source code</a><li class="chapter-item expanded"><i class="fa fa-home"id=home-button></i><a href=https://learnbyexample.github.io/>   My Blog</a><li class="chapter-item expanded"><i class="fa fa-book"id=book-button></i><a href=https://learnbyexample.github.io/books/>   My Books</a><li class="chapter-item expanded"><i class="fa fa-envelope"id=mail-button></i><a href=https://learnbyexample.gumroad.com/l/learnbyexample-weekly>   learnbyexample weekly</a><li class="chapter-item expanded"><i class="fa fa-twitter"id=twitter-button></i><a href=https://twitter.com/learn_byexample>   Twitter</a></ol></div><div class=sidebar-resize-handle id=sidebar-resize-handle></div></nav><div class=page-wrapper id=page-wrapper><div class=page><div id=menu-bar-hover-placeholder></div><div class="menu-bar sticky bordered"id=menu-bar><div class=left-buttons><button aria-label="Toggle Table of Contents"title="Toggle Table of Contents"aria-controls=sidebar class=icon-button id=sidebar-toggle type=button><i class="fa fa-bars"></i></button><button aria-label="Change theme"title="Change theme"aria-controls=theme-list aria-expanded=false aria-haspopup=true class=icon-button id=theme-toggle type=button><i class="fa fa-paint-brush"></i></button><ul aria-label=Themes class=theme-popup id=theme-list role=menu><li role=none><button class=theme id=light role=menuitem>Light (default)</button><li role=none><button class=theme id=rust role=menuitem>Rust</button><li role=none><button class=theme id=coal role=menuitem>Coal</button><li role=none><button class=theme id=navy role=menuitem>Navy</button><li role=none><button class=theme id=ayu role=menuitem>Ayu</button></ul><button aria-label="Toggle Searchbar"title="Search. (Shortkey: s)"aria-controls=searchbar aria-expanded=false aria-keyshortcuts=S class=icon-button id=search-toggle type=button><i class="fa fa-search"></i></button></div><h1 class=menu-title>CLI text processing with GNU awk</h1><div class=right-buttons><a aria-label=Blog href=https://learnbyexample.github.io title=Blog> <i class="fa fa-home"id=home-button></i> </a><a aria-label=Twitter href=https://twitter.com/learn_byexample title=Twitter> <i class="fa fa-twitter"id=twitter-button></i> </a><a aria-label="Git repository"title="Git repository"href=https://github.com/learnbyexample/learn_gnuawk> <i class="fa fa-github"id=git-repository-button></i> </a></div></div><div class=hidden id=search-wrapper><form class=searchbar-outer id=searchbar-outer><input placeholder="Search this book ..."aria-controls=searchresults-outer aria-describedby=searchresults-header id=searchbar name=searchbar type=search></form><div class="searchresults-outer hidden"id=searchresults-outer><div class=searchresults-header id=searchresults-header></div><ul id=searchresults></ul></div></div><script>document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });</script><div class=content id=content><main><div class=sidetoc><nav class=pagetoc></nav></div><h1 id=regular-expressions><a class=header href=#regular-expressions>Regular Expressions</a></h1><p>Regular Expressions is a versatile tool for text processing. It helps to precisely define a matching criteria. For learning and understanding purposes, one can view regular expressions as a mini-programming language in itself, specialized for text processing. Parts of a regular expression can be saved for future use, analogous to variables and functions. There are ways to perform AND, OR, NOT conditionals, features to concisely define repetition to avoid manual replication and so on.<p>Here are some common use cases:<ul><li>Sanitizing a string to ensure that it satisfies a known set of rules. For example, to check if a given string matches password rules.<li>Filtering or extracting portions on an abstract level like alphabets, digits, punctuation and so on.<li>Qualified string replacement. For example, at the start or the end of a string, only whole words, based on surrounding text, etc.</ul><p>This chapter will cover regular expressions as implemented in <code>awk</code>. Most of <code>awk</code>'s regular expression syntax is similar to Extended Regular Expression (ERE) supported by <code>grep -E</code> and <code>sed -E</code>. Unless otherwise indicated, examples and descriptions will assume ASCII input.<blockquote><p><img alt=info src=images/info.svg> See also <a href=https://pubs.opengroup.org/onlinepubs/9799919799/basedefs/V1_chap09.html>POSIX specification</a> for regular expressions and <a href=https://unix.stackexchange.com/q/119905/109046>unix.stackexchange: Why does my regular expression work in X but not in Y?</a> See my <a href=https://learnbyexample.github.io/gnu-bre-ere-cheatsheet/>blog post</a> for differences between regexp features supported by <code>grep</code>, <code>sed</code> and <code>awk</code>.</blockquote><blockquote><p><img alt=info src=images/info.svg> The <a href=https://github.com/learnbyexample/learn_gnuawk/tree/master/example_files>example_files</a> directory has all the files used in the examples.</blockquote><h2 id=syntax-and-variable-assignment><a class=header href=#syntax-and-variable-assignment>Syntax and variable assignment</a></h2><p>As seen in the previous chapter, the syntax is <code>string ~ /regexp/</code> to check if the given string satisfies the rules specified by the regexp. And <code>string !~ /regexp/</code> to invert the condition. By default, <code>$0</code> is checked if the string isn't specified. You can also save a regexp literal in a variable by adding <code>@</code> as a prefix. This is needed because <code>/regexp/</code> by itself would mean <code>$0 ~ /regexp/</code>.<pre><code class=language-bash>$ printf 'spared no one\ngrasped\nspar\n' | awk '/ed/'
spared no one
grasped

$ printf 'spared no one\ngrasped\nspar\n' | awk 'BEGIN{r = @/ed/} $0 ~ r'
spared no one
grasped
</code></pre><h2 id=string-anchors><a class=header href=#string-anchors>String Anchors</a></h2><p>In the examples seen so far, the regexp was a simple string value without any special characters. Also, the regexp pattern evaluated to <code>true</code> if it was found anywhere in the string. Instead of matching anywhere in the string, restrictions can be specified. These restrictions are made possible by assigning special meaning to certain characters and escape sequences. The characters with special meaning are known as <strong>metacharacters</strong> in regular expressions parlance. In case you need to match those characters literally, you need to escape them with a <code>\</code> character (discussed in the <a href=./regular-expressions.html#matching-the-metacharacters>Matching the metacharacters</a> section).<p>There are two string anchors:<ul><li><code>^</code> metacharacter restricts the matching to the start of the string<li><code>$</code> metacharacter restricts the matching to the end of the string</ul><p>By default, <code>awk</code> processes input line by line, using a newline character as the separator. This separator won't be part of the contents in <code>$0</code> but you get back the newline when printing because the default output record separator is also a newline character. Thus, these string anchors can be considered as <em>line</em> anchors when you are processing input content line by line.<pre><code class=language-bash>$ cat anchors.txt
sub par
spar
apparent effort
two spare computers
cart part tart mart

# lines starting with 'sp'
$ awk '/^sp/' anchors.txt
spar

# lines ending with 'ar'
$ awk '/ar$/' anchors.txt
sub par
spar
</code></pre><p>By combining these two anchors, you can restrict the matching to only whole lines. Here's an example:<pre><code class=language-bash># change only whole line 'spar'
# can also use: awk '/^spar$/{$0 = 123} 1'
# can also use: awk '$0=="spar"{$0 = 123} 1'
$ printf 'spared no one\npar\nspar\n' | awk '{sub(/^spar$/, "123")} 1'
spared no one
par
123
</code></pre><p>The anchors can be used by themselves as a pattern too. Helps to insert text at the start/end of a string, emulating string concatenation operations. These might not feel like a useful capability, but combined with other features they become quite a handy tool.<pre><code class=language-bash># add '* ' at the start of every input line
$ printf 'spared no one\ngrasped\nspar\n' | awk '{gsub(/^/, "* ")} 1'
* spared no one
* grasped
* spar

# append '.' only if a line doesn't contain space characters
$ printf 'spared no one\ngrasped\nspar\n' | awk '!/ /{gsub(/$/, ".")} 1'
spared no one
grasped.
spar.
</code></pre><blockquote><p><img alt=info src=images/info.svg> See also the <a href=./gotchas-and-tips.html#behavior-of--and--when-string-contains-newline>Behavior of ^ and $ when string contains newline</a> section.</blockquote><h2 id=word-anchors><a class=header href=#word-anchors>Word Anchors</a></h2><p>The second type of restriction is word anchors. A word character is any alphabet (irrespective of case), digit and the underscore character. You might wonder why there are digits and underscores as well, why not only alphabets? This comes from variable and function naming conventions — typically alphabets, digits and underscores are allowed. So, the definition is more programming oriented than natural language.<p>Use <code>\<</code> to indicate the start of word anchor and <code>\></code> to indicate the end of word anchor. As an alternate, you can use <code>\y</code> to indicate both the start and end of word anchors.<pre><code class=language-bash>$ cat anchors.txt
sub par
spar
apparent effort
two spare computers
cart part tart mart

# words starting with 'par'
$ awk '/\&LTpar/' anchors.txt
sub par
cart part tart mart

# words ending with 'par'
$ awk '/par\>/' anchors.txt
sub par
spar

# replace only whole word 'par'
# note that only lines where the substitution succeeded will be printed
# as the return value of sub/gsub is the number of substitutions made
$ awk 'gsub(/\&LTpar\>/, "***")' anchors.txt
sub ***
</code></pre><blockquote><p><img alt=info src=images/info.svg> Typically <code>\b</code> is used to represent the word anchor (for example, in <code>grep</code>, <code>sed</code>, <code>perl</code>, etc), but in <code>awk</code> the escape sequence <code>\b</code> refers to the backspace character. See also the <a href=./gotchas-and-tips.html#word-boundary-differences>Word boundary differences</a> section.</blockquote><h2 id=opposite-word-anchor><a class=header href=#opposite-word-anchor>Opposite Word Anchor</a></h2><p>The <code>\y</code> escape sequence has an opposite anchor too. <code>\B</code> matches wherever <code>\y</code> doesn't match. This duality will be seen later with some other escape sequences too.<pre><code class=language-bash># match 'par' if it is surrounded by word characters
$ awk '/\Bpar\B/' anchors.txt
apparent effort
two spare computers

# match 'par' but not at the start of a word
$ awk '/\Bpar/' anchors.txt
spar
apparent effort
two spare computers

# match 'par' but not at the end of a word
$ awk '/par\B/' anchors.txt
apparent effort
two spare computers
cart part tart mart
</code></pre><p>Here are some examples for using word boundaries by themselves as a pattern:<pre><code class=language-bash>$ echo 'copper' | awk '{gsub(/\y/, ":")} 1'
:copper:

$ echo 'copper' | awk '{gsub(/\B/, ":")} 1'
c:o:p:p:e:r
</code></pre><blockquote><p><img alt=warning src=images/warning.svg> Negative logic is handy in many text processing situations. But use it with care, you might end up matching things you didn't intend.</blockquote><h2 id=combining-conditions><a class=header href=#combining-conditions>Combining conditions</a></h2><p>Before seeing the next regexp feature, it is good to note that sometimes using logical operators is easier to read and maintain compared to doing everything with regexp.<pre><code class=language-bash># lines starting with 'b' and not containing 'at'
$ awk '/^b/ && !/at/' table.txt
blue cake mug shirt -7

# first field contains 'low'
# or, the last field value is less than 0
$ awk '$1 ~ /low/ || $NF&LT0' table.txt
blue cake mug shirt -7
yellow banana window shoes 3.14
</code></pre><h2 id=alternation><a class=header href=#alternation>Alternation</a></h2><p>Many a times, you'd want to search for multiple terms. In a conditional expression, you can use the logical operators to combine multiple conditions (see the previous section for examples). With regular expressions, the <code>|</code> metacharacter is similar to logical OR. The regular expression will match if any of the patterns separated by <code>|</code> is satisfied.<p>Alternation is similar to using the <code>||</code> operator between two regexps. Having a single regexp helps to write terser code and <code>||</code> cannot be used when substitution is required.<pre><code class=language-bash># match whole word 'par' or string ending with 's'
# same as: awk '/\&LTpar\>/ || /s$/'
$ awk '/\&LTpar\>|s$/' anchors.txt
sub par
two spare computers

# replace 'cat' or 'dog' or 'fox' with '--'
# note the use of gsub for multiple replacements
$ echo 'cats dog bee parrot foxed' | awk '{gsub(/cat|dog|fox/, "--")} 1'
--s -- bee parrot --ed
</code></pre><h2 id=alternation-precedence><a class=header href=#alternation-precedence>Alternation precedence</a></h2><p>There are some tricky corner cases when using alternation. If it is used for filtering a line, there is no ambiguity. However, for use cases like substitution, it depends on a few factors. Say, you want to replace <code>are</code> or <code>spared</code> — which one should get precedence? The bigger word <code>spared</code> or the substring <code>are</code> inside it or based on something else?<p>The alternative which matches earliest in the input gets precedence.<pre><code class=language-bash># here, the output will be the same irrespective of alternation order
# note that 'sub' is used here, so only the first match gets replaced
$ echo 'cats dog bee parrot foxed' | awk '{sub(/bee|parrot|at/, "--")} 1'
c--s dog bee parrot foxed
$ echo 'cats dog bee parrot foxed' | awk '{sub(/parrot|at|bee/, "--")} 1'
c--s dog bee parrot foxed
</code></pre><p>In case of matches starting from the same location, for example <code>spar</code> and <code>spared</code>, the longest matching portion gets precedence. Unlike other regular expression implementations, left-to-right priority for alternation comes into play only if the length of the matches are the same. See <a href=./regular-expressions.html#longest-match-wins>Longest match wins</a> and <a href=./regular-expressions.html#backreferences>Backreferences</a> sections for more examples. See <a href=https://www.regular-expressions.info/alternation.html>regular-expressions: alternation</a> for more information on this topic.<pre><code class=language-bash>$ echo 'spared party parent' | awk '{sub(/spa|spared/, "**")} 1'
** party parent
$ echo 'spared party parent' | awk '{sub(/spared|spa/, "**")} 1'
** party parent

# other regexp flavors like Perl have left-to-right priority
$ echo 'spared party parent' | perl -pe 's/spa|spared/**/'
**red party parent
</code></pre><h2 id=grouping><a class=header href=#grouping>Grouping</a></h2><p>Often, there are some common things among the regular expression alternatives. It could be common characters or qualifiers like the anchors. In such cases, you can group them using a pair of parentheses metacharacters. Similar to <code>a(b+c)d = abd+acd</code> in maths, you get <code>a(b|c)d = abd|acd</code> in regular expressions.<pre><code class=language-bash># without grouping
$ printf 'red\nreform\nread\narrest\n' | awk '/reform|rest/'
reform
arrest
# with grouping
$ printf 'red\nreform\nread\narrest\n' | awk '/re(form|st)/'
reform
arrest

# without grouping
$ awk '/\&LTpar\>|\&LTpart\>/' anchors.txt
sub par
cart part tart mart
# taking out common anchors
$ awk '/\<(par|part)\>/' anchors.txt
sub par
cart part tart mart
# taking out common characters as well
# you'll later learn a better technique instead of using an empty alternate
$ awk '/\&LTpar(|t)\>/' anchors.txt
sub par
cart part tart mart
</code></pre><h2 id=matching-the-metacharacters><a class=header href=#matching-the-metacharacters>Matching the metacharacters</a></h2><p>You have already seen a few metacharacters and escape sequences that help compose a regular expression. To match the metacharacters literally, i.e. to remove their special meaning, prefix those characters with a <code>\</code> character. To indicate a literal <code>\</code> character, use <code>\\</code>.<p>Unlike <code>grep</code> and <code>sed</code>, the string anchors have to be always escaped to match them literally as there is no BRE mode in <code>awk</code>. They do not lose their special meaning even when not used in their customary positions.<pre><code class=language-bash># awk '/b^2/' will not work even though ^ isn't being used as anchor
# b^2 will work for both grep and sed if you use BRE syntax
$ printf 'a^2 + b^2 - C*3\nd = c^2' | awk '/b\^2/'
a^2 + b^2 - C*3

# note that ')' doesn't need to be escaped
$ echo '(a*b) + c' | awk '{gsub(/\(|)/, "")} 1'
a*b + c

$ printf '%s\n' '\learn\by\example' | awk '{gsub(/\\/, "/")} 1'
/learn/by/example
</code></pre><blockquote><p><img alt=info src=images/info.svg> Handling the replacement section metacharacters will be discussed in the <a href=./regular-expressions.html#backreferences>Backreferences</a> section.</blockquote><h2 id=using-string-literal-as-a-regexp><a class=header href=#using-string-literal-as-a-regexp>Using string literal as a regexp</a></h2><p>The first argument to the <code>sub</code> and <code>gsub</code> functions can be a string as well, which will then be converted to a regexp. This is handy in a few cases. For example, if you have many <code>/</code> characters in the search pattern, it might become easier to use a string literal instead of a regexp.<pre><code class=language-bash>$ p='/home/learnbyexample/reports'
$ echo "$p" | awk '{sub(/\/home\/learnbyexample\//, "~/")} 1'
~/reports
$ echo "$p" | awk '{sub("/home/learnbyexample/", "~/")} 1'
~/reports

# filtering example
$ printf '/home/joe/1\n/home/john/1\n' | awk '/\/home\/joe\//'
/home/joe/1
$ printf '/home/joe/1\n/home/john/1\n' | awk '$0 ~ "/home/joe/"'
/home/joe/1
</code></pre><p>In the above examples, the string literal was supplied directly. But any other expression or variable can be used as well, examples for which will be shown later in this chapter. The reason why string isn't always used to represent regexp is that the special meaning for the <code>\</code> character will clash. For example:<pre><code class=language-bash>$ awk 'gsub("\&LTpar\>", "X")' anchors.txt
awk: cmd. line:1: warning: escape sequence `\<' treated as plain `<'
awk: cmd. line:1: warning: escape sequence `\>' treated as plain `>'

# you'll need \\ to represent a single \
$ awk 'gsub("\\&LTpar\\>", "X")' anchors.txt
sub X
# regexp literal is better suited in these cases
$ awk 'gsub(/\&LTpar\>/, "X")' anchors.txt
sub X

# another example
$ printf '%s\n' '\learn\by\example' | awk '{gsub("\\\\", "/")} 1'
/learn/by/example
$ printf '%s\n' '\learn\by\example' | awk '{gsub(/\\/, "/")} 1'
/learn/by/example
</code></pre><blockquote><p><img alt=info src=images/info.svg> See <a href=https://www.gnu.org/software/gawk/manual/gawk.html#Gory-Details>gawk manual: Gory details</a> for more information than you'd want to know.</blockquote><h2 id=the-dot-meta-character><a class=header href=#the-dot-meta-character>The dot meta character</a></h2><p>The dot metacharacter serves as a placeholder to match any character (including the newline character). Later you'll learn how to define your own custom placeholder for a limited set of characters.<pre><code class=language-bash># 3 character sequence starting with 'c' and ending with 't'
$ echo 'tac tin cot abc:tyz excited' | awk '{gsub(/c.t/, "-")} 1'
ta-in - ab-yz ex-ed

# any character followed by 3 and again any character
$ printf '42\t3500\n' | awk '{gsub(/.3./, ":")} 1'
42:00

# example to show that . matches \n as well
# 'c' followed by any character followed by 'x'
$ awk 'BEGIN{s="abc\nxyz"; sub(/c.x/, " ", s); print s}'
ab yz
</code></pre><h2 id=quantifiers><a class=header href=#quantifiers>Quantifiers</a></h2><p>Alternation helps you match one among multiple patterns. Combining the dot metacharacter with quantifiers (and alternation if needed) paves a way to perform logical AND between patterns. For example, to check if a string matches two patterns with any number of characters in between. Quantifiers can be applied to characters, groupings and some more constructs that'll be discussed later. Apart from the ability to specify exact quantity and bounded range, these can also match unbounded varying quantities.<p>First up, the <code>?</code> metacharacter which quantifies a character or group to match <code>0</code> or <code>1</code> times. This helps to define optional patterns and build terser patterns.<pre><code class=language-bash># same as: awk '{gsub(/\<(fe.d|fed)\>/, "X")} 1'
$ echo 'fed fold fe:d feeder' | awk '{gsub(/\&LTfe.?d\>/, "X")} 1'
X fold X feeder

# same as: awk '/\&LTpar(|t)\>/'
$ awk '/\&LTpart?\>/' anchors.txt
sub par
cart part tart mart

# same as: awk '{gsub(/part|parrot/, "X")} 1'
$ echo 'par part parrot parent' | awk '{gsub(/par(ro)?t/, "X")} 1'
par X X parent
# same as: awk '{gsub(/part|parrot|parent/, "X")} 1'
$ echo 'par part parrot parent' | awk '{gsub(/par(en|ro)?t/, "X")} 1'
par X X X

# matches '<' or '\<' and they are both replaced with '\<'
$ echo 'apple \< fig ice < apple cream <' | awk '{gsub(/\\?&LT/, "\\<")} 1'
apple \< fig ice \< apple cream \<
</code></pre><p>The <code>*</code> metacharacter quantifies a character or group to match <code>0</code> or more times.<pre><code class=language-bash># 'f' followed by zero or more of 'e' followed by 'd'
$ echo 'fd fed fod fe:d feeeeder' | awk '{gsub(/fe*d/, "X")} 1'
X X fod fe:d Xer

# zero or more of '1' followed by '2'
$ echo '3111111111125111142' | awk '{gsub(/1*2/, "-")} 1'
3-511114-
</code></pre><p>The <code>+</code> metacharacter quantifies a character or group to match <code>1</code> or more times.<pre><code class=language-bash># 'f' followed by one or more of 'e' followed by 'd'
$ echo 'fd fed fod fe:d feeeeder' | awk '{gsub(/fe+d/, "X")} 1'
fd X fod fe:d Xer

# one or more of '1' followed by optional '4' and then '2'
$ echo '3111111111125111142' | awk '{gsub(/1+4?2/, "-")} 1'
3-5-
</code></pre><p>You can specify a range of integer numbers, both bounded and unbounded, using <code>{}</code> metacharacters. There are four ways to use this quantifier as listed below:<div class=table-wrapper><table><thead><tr><th>Quantifier<th>Description<tbody><tr><td><code>{m,n}</code><td>match <code>m</code> to <code>n</code> times<tr><td><code>{m,}</code><td>match at least <code>m</code> times<tr><td><code>{,n}</code><td>match up to <code>n</code> times (including <code>0</code> times)<tr><td><code>{n}</code><td>match exactly <code>n</code> times</table></div><pre><code class=language-bash># note that stray characters like space are not allowed anywhere within {}
$ echo 'ac abc abbc abbbc abbbbbbbbc' | awk '{gsub(/ab{1,4}c/, "X")} 1'
ac X X X abbbbbbbbc

$ echo 'ac abc abbc abbbc abbbbbbbbc' | awk '{gsub(/ab{3,}c/, "X")} 1'
ac abc abbc X X

$ echo 'ac abc abbc abbbc abbbbbbbbc' | awk '{gsub(/ab{,2}c/, "X")} 1'
X X X abbbc abbbbbbbbc

$ echo 'ac abc abbc abbbc abbbbbbbbc' | awk '{gsub(/ab{3}c/, "X")} 1'
ac abc abbc X abbbbbbbbc
</code></pre><blockquote><p><img alt=info src=images/info.svg> The <code>{}</code> metacharacters have to be escaped to match them literally. Similar to the <code>()</code> metacharacters, escaping <code>{</code> alone is enough. If it doesn't conform strictly to any of the four forms listed above, escaping is not needed at all.<pre><code class=language-bash>$ echo 'a{5} = 10' | awk '{sub(/a\{5}/, "x")} 1'
x = 10
$ echo 'report_{a,b}.txt' | awk '{sub(/_{a,b}/, "_c")} 1'
report_c.txt
</code></pre></blockquote><h2 id=conditional-and><a class=header href=#conditional-and>Conditional AND</a></h2><p>Next up, how to construct conditional AND using dot metacharacter and quantifiers.<pre><code class=language-bash># match 'Error' followed by zero or more characters followed by 'valid'
$ echo 'Error: not a valid input' | awk '/Error.*valid/'
Error: not a valid input
</code></pre><p>To allow matching in any order, you'll have to bring in alternation as well.<pre><code class=language-bash># 'cat' followed by 'dog' or 'dog' followed by 'cat'
$ echo 'two cats and a dog' | awk '{gsub(/cat.*dog|dog.*cat/, "pets")} 1'
two pets
$ echo 'two dogs and a cat' | awk '{gsub(/cat.*dog|dog.*cat/, "pets")} 1'
two pets
</code></pre><h2 id=longest-match-wins><a class=header href=#longest-match-wins>Longest match wins</a></h2><p>You've already seen an example where the longest matching portion was chosen if the alternatives started from the same location. For example <code>spar|spared</code> will result in <code>spared</code> being chosen over <code>spar</code>. The same applies whenever there are two or more matching possibilities from the same starting location. For example, <code>f.?o</code> will match <code>foo</code> instead of <code>fo</code> if the input string to match is <code>foot</code>.<pre><code class=language-bash># longest match among 'foo' and 'fo' wins here
$ echo 'foot' | awk '{sub(/f.?o/, "X")} 1'
Xt
# everything will match here
$ echo 'car bat cod map scat dot abacus' | awk '{sub(/.*/, "X")} 1'
X

# longest match happens when (1|2|3)+ matches up to '1233' only
# so that '12apple' can match as well
$ echo 'fig123312apple' | awk '{sub(/g(1|2|3)+(12apple)?/, "X")} 1'
fiX
# in other implementations like Perl, that is not the case
# precedence is left-to-right for greedy quantifiers
$ echo 'fig123312apple' | perl -pe 's/g(1|2|3)+(12apple)?/X/'
fiXapple
</code></pre><p>While determining the longest match, the overall regular expression matching is also considered. That's how the <code>Error.*valid</code> example worked. If <code>.*</code> had consumed everything after <code>Error</code>, there wouldn't be any more characters to try to match <code>valid</code>. So, among the varying quantity of characters to match for <code>.*</code>, the longest portion that satisfies the overall regular expression is chosen. Something like <code>a.*b</code> will match from the first <code>a</code> in the input string to the last <code>b</code>. In other implementations, like Perl, this is achieved through a process called <strong>backtracking</strong>. These approaches have their own advantages and disadvantages and have cases where the pattern can result in exponential time consumption.<pre><code class=language-bash># from the start of line to the last 'b' in the line
$ echo 'car bat cod map scat dot abacus' | awk '{sub(/.*b/, "-")} 1'
-acus

# from the first 'b' to the last 't' in the line
$ echo 'car bat cod map scat dot abacus' | awk '{sub(/b.*t/, "-")} 1'
car - abacus

# from the first 'b' to the last 'at' in the line
$ echo 'car bat cod map scat dot abacus' | awk '{sub(/b.*at/, "-")} 1'
car - dot abacus

# here 'm*' will match 'm' zero times as that gives the longest match
$ echo 'car bat cod map scat dot abacus' | awk '{sub(/a.*m*/, "-")} 1'
c-
</code></pre><h2 id=character-classes><a class=header href=#character-classes>Character classes</a></h2><p>To create a custom placeholder for a limited set of characters, enclose them inside <code>[]</code> metacharacters. It is similar to using single character alternations inside a grouping, but with added flexibility and features. Character classes have their own versions of metacharacters and provide special predefined sets for common use cases. Quantifiers are also applicable to character classes.<pre><code class=language-bash># same as: awk '/cot|cut/' and awk '/c(o|u)t/'
$ printf 'cute\ncat\ncot\ncoat\ncost\nscuttle\n' | awk '/c[ou]t/'
cute
cot
scuttle

# same as: awk '/.(a|e|o)t/'
$ printf 'meeting\ncute\nboat\nat\nfoot\n' | awk '/.[aeo]t/'
meeting
boat
foot

# same as: awk '{gsub(/\<(s|o|t)(o|n)\>/, "X")} 1'
$ echo 'no so in to do on' | awk '{gsub(/\<[sot][on]\>/, "X")} 1'
no X in X do X

# lines made up of letters 'o' and 'n', line length at least 2
# words.txt contains dictionary words, one word per line
$ awk '/^[on]{2,}$/' words.txt
no
non
noon
on
</code></pre><h2 id=character-class-metacharacters><a class=header href=#character-class-metacharacters>Character class metacharacters</a></h2><p>Character classes have their own metacharacters to help define the sets succinctly. Metacharacters outside of character classes like <code>^</code>, <code>$</code>, <code>()</code> etc either don't have special meaning or have a completely different one inside the character classes.<p>First up, the <code>-</code> metacharacter that helps to define a range of characters instead of having to specify them all individually.<pre><code class=language-bash># same as: awk '{gsub(/[0123456789]+/, "-")} 1'
$ echo 'Sample123string42with777numbers' | awk '{gsub(/[0-9]+/, "-")} 1'
Sample-string-with-numbers

# whole words made up of lowercase alphabets and digits only
$ echo 'coat Bin food tar12 best' | awk '{gsub(/\<[a-z0-9]+\>/, "X")} 1'
X Bin X X X

# whole words made up of lowercase alphabets, starting with 'p' to 'z'
$ echo 'road i post grip read eat pit' | awk '{gsub(/\<[p-z][a-z]*\>/, "X")} 1'
X i X grip X eat X
</code></pre><p>Character classes can also be used to construct numeric ranges. However, it is easy to miss corner cases and some ranges are complicated to design.<pre><code class=language-bash># numbers between 10 to 29
$ echo '23 154 12 26 34' | awk '{gsub(/\<[12][0-9]\>/, "X")} 1'
X 154 X X 34

# numbers >= 100 with optional leading zeros
$ echo '0501 035 154 12 26 98234' | awk '{gsub(/\&LT0*[1-9][0-9]{2,}\>/, "X")} 1'
X 035 X 12 26 X
</code></pre><p>Next metacharacter is <code>^</code> which has to be specified as the first character of the character class. It negates the set of characters, so all characters other than those specified will be matched. As highlighted earlier, handle negative logic with care, you might end up matching more than you wanted.<pre><code class=language-bash># replace all non-digit characters
$ echo 'Sample123string42with777numbers' | awk '{gsub(/[^0-9]+/, "-")} 1'
-123-42-777-

# delete the last two columns
$ echo 'apple:123:banana:cherry' | awk '{sub(/(:[^:]+){2}$/, "")} 1'
apple:123

# sequence of characters surrounded by a unique character
$ echo 'I like "mango" and "guava"' | awk '{gsub(/"[^"]+"/, "X")} 1'
I like X and X

# sometimes it is simpler to positively define a set than negation
# same as: awk '/^[^aeiou]*$/'
$ printf 'tryst\nfun\nglyph\npity\nwhy\n' | awk '!/[aeiou]/'
tryst
glyph
why
</code></pre><p>Some commonly used character sets have predefined escape sequences:<ul><li><code>\w</code> matches all <strong>word</strong> characters <code>[a-zA-Z0-9_]</code> (recall the description for word boundaries)<li><code>\W</code> matches all non-word characters (recall duality seen earlier, like <code>\y</code> and <code>\B</code>)<li><code>\s</code> matches all <strong>whitespace</strong> characters: tab, newline, vertical tab, form feed, carriage return and space<li><code>\S</code> matches all non-whitespace characters</ul><p>These escape sequences <em>cannot</em> be used inside character classes. Also, as mentioned earlier, these definitions assume ASCII input.<pre><code class=language-bash># match all non-word characters
$ printf '%s\n' 'load;err_msg--\/ant,r2..not' | awk '{gsub(/\W+/, "|")} 1'
load|err_msg|ant|r2|not

# replace all sequences of whitespaces with a single space
$ printf 'hi  \v\f  there.\thave   \ra nice\t\tday\n' | awk '{gsub(/\s+/, " ")} 1'
hi there. have a nice day

# \w would simply match w inside character classes
$ printf '%s\n' 'w=y\x+9*3' | awk '{gsub(/[\w=]/, "")} 1'
y\x+9*3
</code></pre><blockquote><p><img alt=warning src=images/warning.svg> <code>awk</code> doesn't support <code>\d</code> and <code>\D</code>, commonly featured in other implementations as a shortcut for all the digits and non-digits.<pre><code class=language-bash># \d will match just the 'd' character and produces a warning as well
$ printf '%s\n' '42\d123' | awk '{gsub(/\d+/, "-")} 1'
awk: cmd. line:1: warning: regexp escape sequence
                  '\d' is not a known regexp operator
42\-123

# \d here matches all digit characters
$ printf '%s\n' '42\d123' | perl -pe 's/\d+/-/g'
-\d-
</code></pre></blockquote><h2 id=named-character-sets><a class=header href=#named-character-sets>Named character sets</a></h2><p>A named character set is defined by a name enclosed between <code>[:</code> and <code>:]</code> and has to be used within a character class <code>[]</code>, along with other characters as needed.<div class=table-wrapper><table><thead><tr><th>Named set<th>Description<tbody><tr><td><code>[:digit:]</code><td><code>[0-9]</code><tr><td><code>[:lower:]</code><td><code>[a-z]</code><tr><td><code>[:upper:]</code><td><code>[A-Z]</code><tr><td><code>[:alpha:]</code><td><code>[a-zA-Z]</code><tr><td><code>[:alnum:]</code><td><code>[0-9a-zA-Z]</code><tr><td><code>[:xdigit:]</code><td><code>[0-9a-fA-F]</code><tr><td><code>[:cntrl:]</code><td>control characters — first 32 ASCII characters and 127th (DEL)<tr><td><code>[:punct:]</code><td>all the punctuation characters<tr><td><code>[:graph:]</code><td><code>[:alnum:]</code> and <code>[:punct:]</code><tr><td><code>[:print:]</code><td><code>[:alnum:]</code>, <code>[:punct:]</code> and space<tr><td><code>[:blank:]</code><td>space and tab characters<tr><td><code>[:space:]</code><td>whitespace characters, same as <code>\s</code></table></div><p>Here are some examples:<pre><code class=language-bash>$ s='err_msg xerox ant m_2 P2 load1 eel'
$ echo "$s" | awk '{gsub(/\<[[:lower:]]+\>/, "X")} 1'
err_msg X X m_2 P2 load1 X

$ echo "$s" | awk '{gsub(/\<[[:lower:]_]+\>/, "X")} 1'
X X X m_2 P2 load1 X

$ echo "$s" | awk '{gsub(/\<[[:alnum:]]+\>/, "X")} 1'
err_msg X X m_2 X X X

# retain only punctuation characters
$ echo ',pie tie#ink-eat_42' | awk '{gsub(/[^[:punct:]]+/, "")} 1'
,#-_
</code></pre><h2 id=matching-character-class-metacharacters-literally><a class=header href=#matching-character-class-metacharacters-literally>Matching character class metacharacters literally</a></h2><p>Specific placement is needed to match character class metacharacters literally. Or, they can be escaped by prefixing <code>\</code> to avoid having to remember the different rules. As <code>\</code> is special inside character class, use <code>\\</code> to represent it literally.<p><code>-</code> should be the first or last character.<pre><code class=language-bash>$ echo 'ab-cd gh-c 12-423' | awk '{gsub(/[a-z-]{2,}/, "X")} 1'
X X 12-423

# or escaped with \
$ echo 'ab-cd gh-c 12-423' | awk '{gsub(/[a-z\-0-9]{2,}/, "X")} 1'
X X X
</code></pre><p><code>]</code> should be the first character.<pre><code class=language-bash># no match
$ printf 'int a[5]\nfig\n1+1=2\n' | awk '/[=]]/'

# correct usage
$ printf 'int a[5]\nfig\n1+1=2\n' | awk '/[]=]/'
int a[5]
1+1=2
</code></pre><p><code>[</code> can be used anywhere in the character set. Using <code>[][]</code> will match both <code>[</code> and <code>]</code>.<pre><code class=language-bash>$ echo 'int a[5].y' | awk '{gsub(/[x[y.]/, "")} 1'
int a5]

$ printf 'int a[5]\nfig\n1+1=2\nwho]' | awk '/[][]/'
int a[5]
who]
</code></pre><p><code>^</code> should be other than the first character.<pre><code class=language-bash>$ echo 'f*(a^b) - 3*(a+b)/(a-b)' | awk '{gsub(/a[+^]b/, "c")} 1'
f*(c) - 3*(c)/(a-b)
</code></pre><blockquote><p><img alt=warning src=images/warning.svg> Combinations like <code>[.</code> or <code>[:</code> cannot be used together to mean two individual characters, as they have special meaning within <code>[]</code>. See <a href=https://www.gnu.org/software/gawk/manual/gawk.html#Bracket-Expressions>gawk manual: Using Bracket Expressions</a> for more details.<pre><code class=language-bash>$ echo 'int a[5]' | awk '/[x[.y]/'
awk: cmd. line:1: error: Unmatched [, [^, [:, [., or [=: /[x[.y]/
$ echo 'int a[5]' | awk '/[x[y.]/'
int a[5]
</code></pre></blockquote><h2 id=escape-sequences><a class=header href=#escape-sequences>Escape sequences</a></h2><p>Certain ASCII characters like tab <code>\t</code>, carriage return <code>\r</code>, newline <code>\n</code>, etc have escape sequences to represent them. Additionally, any character can be represented using their ASCII value in octal <code>\NNN</code> or hexadecimal <code>\xNN</code> formats. Unlike character set escape sequences like <code>\w</code>, these can be used inside character classes.<pre><code class=language-bash># \t represents the tab character
$ printf 'apple\tbanana\tcherry\n' | awk '{gsub(/\t/, " ")} 1'
apple banana cherry

# these escape sequences work inside character class too
$ printf 'a\t\r\fb\vc\n' | awk '{gsub(/[\t\v\f\r]+/, ":")} 1'
a:b:c

# representing single quotes
# use \047 for octal format
$ echo "universe: '42'" | awk '{gsub(/\x27/, "")} 1'
universe: 42
</code></pre><p>If a metacharacter is specified using the ASCII value format, it will still act as the metacharacter.<pre><code class=language-bash># \x5e is ^ character, acts as line anchor here
$ printf 'acorn\ncot\ncat\ncoat\n' | awk '/\x5eco/'
cot
coat

# & metacharacter in replacement will be discussed in a later section
# it represents the entire matched portion
$ echo 'hello world' | awk '{sub(/.*/, "[&]")} 1'
[hello world]
# \x26 in hexadecimal is the & character
$ echo 'hello world' | awk '{sub(/.*/, "[\x26]")} 1'
[hello world]
</code></pre><p>Undefined sequences will result in a warning and treated as the character it escapes.<pre><code class=language-bash>$ echo 'read' | awk '{sub(/\d/, "l")} 1'
awk: cmd. line:1: warning: regexp escape sequence
                  '\d' is not a known regexp operator
real
</code></pre><p>Support for Unicode characters requiring up to 8 hexadecimal digits with <code>\u</code> was added recently.<pre><code class=language-bash>$ awk 'BEGIN{print "\u3b1\u3bb\u3b5\u3c0\u3bf\u3cd"}'
αλεπού

# there's no way to separate the hexadecimal digits from characters
# that follow, so you'll have to separate them manually
$ awk 'BEGIN{print "cag\u308" "ed"}'
cag̈ed
</code></pre><blockquote><p><img alt=info src=images/info.svg> See <a href=https://www.gnu.org/software/gawk/manual/gawk.html#Escape-Sequences>gawk manual: Escape Sequences</a> for full list and other details. See also <a href=https://codepoints.net/>codepoints.net</a>, a site dedicated for Unicode characters.</blockquote><h2 id=replace-a-specific-occurrence><a class=header href=#replace-a-specific-occurrence>Replace a specific occurrence</a></h2><p>The third substitution function is <code>gensub</code> which can be used instead of both the <code>sub</code> and <code>gsub</code> functions. Syntax wise, <code>gensub</code> needs minimum three arguments. The third argument is used to indicate whether you want to replace all occurrences with <code>"g"</code> or a specific occurrence by passing a number. Another difference is that <code>gensub</code> returns a string value (irrespective of the substitution operation succeeding) instead of modifying the input.<pre><code class=language-bash>$ s='apple:banana:cherry:fig:mango'

# same as: sed 's/:/-/2'
# replace only the second occurrence of ':' with '-'
# note that the output of gensub is passed to print here
$ echo "$s" | awk '{print gensub(/:/, "-", 2)}'
apple:banana-cherry:fig:mango

# same as: sed -E 's/[^:]+/X/3'
# replace only the third field with '123'
$ echo "$s" | awk '{print gensub(/[^:]+/, "123", 3)}'
apple:banana:123:fig:mango
</code></pre><p>The fourth argument for the <code>gensub</code> function allows you to specify a string or a variable on which the substitution has to be performed. Default is <code>$0</code>, as seen in the previous examples.<pre><code class=language-bash># same as: awk '{gsub(/[aeiou]/, "X", $4)} 1'
$ echo '1 good 2 apples' | awk '{$4 = gensub(/[aeiou]/, "X", "g", $4)} 1'
1 good 2 XpplXs
</code></pre><h2 id=backreferences><a class=header href=#backreferences>Backreferences</a></h2><p>The grouping metacharacters <code>()</code> are also known as <strong>capture groups</strong>. Similar to variables in programming languages, the portion captured by <code>()</code> can be referred later using backreferences. The syntax is <code>\N</code> where <code>N</code> is the capture group you want. Leftmost <code>(</code> in the regular expression is <code>\1</code>, next one is <code>\2</code> and so on up to <code>\9</code>. The <code>&</code> metacharacter represents entire matched string. As <code>\</code> is already special inside double quotes, you'll have to use <code>"\\1"</code> to represent <code>\1</code>.<blockquote><p><img alt=info src=images/info.svg> Backreferences of the form <code>\N</code> can only be used with the <code>gensub</code> function. <code>&</code> can be used with the <code>sub</code>, <code>gsub</code> and <code>gensub</code> functions. <code>\0</code> can also be used instead of <code>&</code> with the <code>gensub</code> function.</blockquote><pre><code class=language-bash># replace \\ with \
# replace \ with an empty string
$ s='\[\] and \\w and \[a-zA-Z0-9\_\]'
$ echo "$s" | awk '{print gensub(/(\\?)\\/, "\\1", "g")}'
[] and \w and [a-zA-Z0-9_]

# duplicate the first column value and add it as the final column
$ echo 'one,2,3.14,42' | awk '{print gensub(/^([^,]+).*/, "&,\\1", 1)}'
one,2,3.14,42,one

# add something at the start and end of string, gensub isn't needed here
$ echo 'hello world' | awk '{sub(/.*/, "Hi. &. Have a nice day")} 1'
Hi. hello world. Have a nice day

# here {N} refers to the last but Nth occurrence
$ s='car,art,pot,tap,urn,ray,ear'
$ echo "$s" | awk '{print gensub(/(.*),((.*,){2})/, "\\1[]\\2", 1)}'
car,art,pot,tap[]urn,ray,ear
</code></pre><blockquote><p><img alt=warning src=images/warning.svg> See <a href=https://unix.stackexchange.com/q/579889/109046>unix.stackexchange: Why doesn't this sed command replace the 3rd-to-last "and"?</a> for a bug related to the use of word anchors in the <code>((pat){N})</code> generic case.</blockquote><blockquote><p><img alt=warning src=images/warning.svg> Unlike other regular expression implementations, like <code>grep</code> or <code>sed</code> or <code>perl</code>, backreferences cannot be used in the search section in <code>awk</code>. See also <a href=https://unix.stackexchange.com/q/361427/109046>unix.stackexchange: backreference in awk</a>.<pre><code class=language-bash>$ s='effort flee facade oddball rat tool'

# no change
$ echo "$s" | awk '{print gensub(/\w*(\w)\1\w*/, "X", "g")}'
effort flee facade oddball rat tool
# whole words that have at least one consecutive repeated character
$ echo "$s" | sed -E 's/\w*(\w)\1\w*/X/g'
X X facade X rat X
</code></pre></blockquote><p>If a quantifier is applied on a pattern grouped inside <code>()</code> metacharacters, you'll need an outer <code>()</code> group to capture the matching portion. Other flavors like Perl provide non-capturing groups to handle such cases. In <code>awk</code> you'll have to consider the extra capture groups.<pre><code class=language-bash># note the numbers used in the replacement section
$ s='one,2,3.14,42'
$ echo "$s" | awk '{$0=gensub(/^(([^,]+,){2})([^,]+)/, "[\\1](\\3)", 1)} 1'
[one,2,](3.14),42
</code></pre><p>Here's an example where alternation order matters when the matching portions have the same length. Aim is to delete all whole words unless it starts with <code>g</code> or <code>p</code> and contains <code>y</code>.<pre><code class=language-bash>$ s='tryst,fun,glyph,pity,why,group'

# all words get deleted because \<\w+\> gets priority here
$ echo "$s" | awk '{print gensub(/\<\w+\>|(\<[gp]\w*y\w*\>)/, "\\1", "g")}'
,,,,,

# capture group gets priority here, so words in the capture group are retained
$ echo "$s" | awk '{print gensub(/(\<[gp]\w*y\w*\>)|\<\w+\>/, "\\1", "g")}'
,,glyph,pity,,
</code></pre><p>As <code>\</code> and <code>&</code> are special characters in the replacement section, you'll need to escape them for literal representation.<pre><code class=language-bash>$ echo 'apple and fig' | awk '{sub(/and/, "[&]")} 1'
apple [and] fig
$ echo 'apple and fig' | awk '{sub(/and/, "[\\&]")} 1'
apple [&] fig

$ echo 'apple and fig' | awk '{sub(/and/, "\\")} 1'
apple \ fig
</code></pre><h2 id=case-insensitive-matching><a class=header href=#case-insensitive-matching>Case insensitive matching</a></h2><p>Unlike <code>sed</code> or <code>perl</code>, regular expressions in <code>awk</code> do not directly support the use of flags to change certain behaviors. For example, there is no flag to force the regexp to ignore case while matching.<p>The <code>IGNORECASE</code> special variable controls case sensitivity, which is <code>0</code> by default. By changing it to some other value (which would mean <code>true</code> in a conditional expression), you can match case insensitively. The <code>-v</code> command line option allows you to assign a variable before input is read. The <code>BEGIN</code> block is also often used to change such settings.<pre><code class=language-bash>$ printf 'Cat\ncOnCaT\nscatter\ncot\n' | awk -v IGNORECASE=1 '/cat/'
Cat
cOnCaT
scatter

# for small enough string, you can also use character classes
$ printf 'Cat\ncOnCaT\nscatter\ncot\n' | awk '{gsub(/[cC][aA][tT]/, "(&)")} 1'
(Cat)
cOn(CaT)
s(cat)ter
cot
</code></pre><p>Another way is to use built-in string function <code>tolower</code> to change the input to lowercase first.<pre><code class=language-bash>$ printf 'Cat\ncOnCaT\nscatter\ncot\n' | awk 'tolower($0) ~ /cat/'
Cat
cOnCaT
scatter
</code></pre><h2 id=dynamic-regexp><a class=header href=#dynamic-regexp>Dynamic regexp</a></h2><p>As seen earlier, string literals can be used instead of a regexp to specify the pattern to be matched. Which implies that you can use any expression or a variable as well. This is helpful if you need to compute the regexp based on some conditions or if you are getting the pattern externally, such as user input passed via the <code>-v</code> option from a shell variable.<pre><code class=language-bash>$ r='cat.*dog|dog.*cat'
$ echo 'two cats and a dog' | awk -v ip="$r" '{gsub(ip, "pets")} 1'
two pets

$ awk -v s='ow' '$0 ~ s' table.txt
brown bread mat hair 42
yellow banana window shoes 3.14

# you'll have to make sure to use \\ instead of \
$ r='\\<[12][0-9]\\>'
$ echo '23 154 12 26 34' | awk -v ip="$r" '{gsub(ip, "X")} 1'
X 154 X X 34
</code></pre><blockquote><p><img alt=info src=images/info.svg> See <a href=./using-shell-variables.html#using-shell-variables>Using shell variables</a> chapter for a way to avoid having to escape backslashes.</blockquote><p>Sometimes, user input has to be treated literally instead of as a regexp pattern. In such cases, you'll need to escape all the regexp metacharacters. Below example shows how to do it for the search section. For the replace section, you only have to escape the <code>\</code> and <code>&</code> characters.<pre><code class=language-bash>$ awk -v s='(a.b)^{c}|d' 'BEGIN{gsub(/[{[(^$*?+.|\\]/, "\\\\&", s); print s}'
\(a\.b)\^\{c}\|d

$ echo 'f*(a^b) - 3*(a^b)' |
     awk -v s='(a^b)' '{gsub(/[{[(^$*?+.|\\]/, "\\\\&", s); gsub(s, "c")} 1'
f*c - 3*c

# match the input string literally, but only at the end of string
$ echo 'f*(a^b) - 3*(a^b)' |
     awk -v s='(a^b)' '{gsub(/[{[(^$*?+.|\\]/, "\\\\&", s); gsub(s "$", "c")} 1'
f*(a^b) - 3*c
</code></pre><blockquote><p><img alt=info src=images/info.svg> See <a href=https://learnbyexample.github.io/escaping-madness-awk-literal-field-separator/>my blog post</a> for more details about escaping metacharacters.</blockquote><blockquote><p><img alt=info src=images/info.svg> If you need to just match literally instead of substitution, you can use the <code>index</code> function. See the <a href=./built-in-functions.html#index>index</a> section for details.</blockquote><h2 id=summary><a class=header href=#summary>Summary</a></h2><p>Regular expressions is a feature that you'll encounter in multiple command line programs and programming languages. It is a versatile tool for text processing. Although the features in <code>awk</code> are less compared to those found in programming languages, they are sufficient for most of the tasks you'll need for command line usage. It takes a lot of time to get used to syntax and features of regular expressions, so I'll encourage you to practice a lot and maintain notes. It'd also help to consider it as a mini-programming language in itself for its flexibility and complexity.<h2 id=exercises><a class=header href=#exercises>Exercises</a></h2><blockquote><p><img alt=info src=images/info.svg> The <a href=https://github.com/learnbyexample/learn_gnuawk/tree/master/exercises>exercises</a> directory has all the files used in this section.</blockquote><p><strong>1)</strong> For the input file <code>patterns.txt</code>, display all lines that start with <code>den</code> or end with <code>ly</code>.<pre><code class=language-bash>$ awk ##### add your solution here
2 lonely
dent
lovely
</code></pre><p><strong>2)</strong> For the input file <code>patterns.txt</code>, replace all occurrences of <code>42</code> with <code>[42]</code> unless it is at the edge of a word. Display only the modified lines.<pre><code class=language-bash>$ awk ##### add your solution here
Hi[42]Bye nice1[42]3 bad42
eqn2 = pressure*3+42/5-1[42]56
cool_[42]a 42fake
_[42]_
</code></pre><p><strong>3)</strong> For the input file <code>patterns.txt</code>, add <code>[]</code> around words starting with <code>s</code> and containing <code>e</code> and <code>t</code> in any order. Display only the modified lines.<pre><code class=language-bash>$ awk ##### add your solution here
[sets] tests Sauerkraut
[site] cite kite bite [store_2]
[subtle] sequoia
a [set]
</code></pre><p><strong>4)</strong> For the input file <code>patterns.txt</code>, replace the space character that occurs after a word ending with <code>a</code> or <code>r</code> with a newline character, only if the line also contains an uppercase letter. Display only the modified lines. For example, <code>A car park</code> should get converted to <code>A car</code> and <code>park</code> separated by a newline. But <code>car far tar</code> shouldn't be matched as there's no uppercase letter in this line.<pre><code class=language-bash>$ awk ##### add your solution here
par
car
tar
far
Cart
Not a
pip DOWN
</code></pre><p><strong>5)</strong> For the input file <code>patterns.txt</code>, replace all occurrences of <code>*[5]</code> with <code>2</code>. Display only the modified lines.<pre><code class=language-bash>$ awk ##### add your solution here
(9-2)2
</code></pre><p><strong>6)</strong> <code>awk '/\<[a-z](on|no)[a-z]\>/'</code> is same as <code>awk '/\<[a-z][on]{2}[a-z]\>/'</code>. True or False? Sample input shown below might help to understand the differences, if any.<pre><code class=language-bash>$ printf 'known\nmood\nknow\npony\ninns\n'
known
mood
know
pony
inns
</code></pre><p><strong>7)</strong> For the input file <code>patterns.txt</code>, display all lines starting with <code>hand</code> and ending immediately with <code>s</code> or <code>y</code> or <code>le</code> or no further characters. For example, <code>handed</code> shouldn't be matched even though it starts with <code>hand</code>.<pre><code class=language-bash>$ awk ##### add your solution here
handle
handy
hands
hand
</code></pre><p><strong>8)</strong> For the input file <code>patterns.txt</code>, replace <code>42//5</code> or <code>42/5</code> with <code>8</code>. Display only the modified lines.<pre><code class=language-bash>$ awk ##### add your solution here
eqn3 = r*42-5/3+42///5-83+a
eqn1 = a+8-c
eqn2 = pressure*3+8-14256
</code></pre><p><strong>9)</strong> For the given quantifiers, what would be the equivalent form using the <code>{m,n}</code> representation?<ul><li><code>?</code> is same as<li><code>*</code> is same as<li><code>+</code> is same as</ul><p><strong>10)</strong> <code>(a*|b*)</code> is same as <code>(a|b)*</code> — True or False?<p><strong>11)</strong> For the input file <code>patterns.txt</code>, construct two different regexps to get the outputs as shown below. Display only the modified lines.<pre><code class=language-bash># delete from '(' till the next ')'
$ awk ##### add your solution here
a/b + c%d
*[5]
def factorial
12- *4)
Hi there. Nice day

# delete from '(' till the next ')' but not if there is '(' in between
$ awk ##### add your solution here
a/b + c%d
*[5]
def factorial
12- (e+*4)
Hi there. Nice day(a
</code></pre><p><strong>12)</strong> For the input file <code>anchors.txt</code>, convert markdown anchors to corresponding hyperlinks as shown below.<pre><code class=language-bash>$ cat anchors.txt
# &LTa name="regular-expressions">&LT/a>Regular Expressions
## &LTa name="subexpression-calls">&LT/a>Subexpression calls
## &LTa name="the-dot-meta-character">&LT/a>The dot meta character

$ awk ##### add your solution here
[Regular Expressions](#regular-expressions)
[Subexpression calls](#subexpression-calls)
[The dot meta character](#the-dot-meta-character)
</code></pre><p><strong>13)</strong> Display lines from <code>sample.txt</code> that satisfy both of these conditions:<ul><li><code>to</code> or <code>he</code> matched irrespective of case<li><code>World</code> or <code>No</code> matched case sensitively</ul><pre><code class=language-bash>$ awk ##### add your solution here
Hello World
No doubt you like it too
</code></pre><p><strong>14)</strong> Given sample strings have fields separated by <code>,</code> and field values cannot be empty. Replace the third field with <code>42</code>.<pre><code class=language-bash>$ echo 'lion,ant,road,neon' | awk ##### add your solution here
lion,ant,42,neon

$ echo '_;3%,.,=-=,:' | awk ##### add your solution here
_;3%,.,42,:
</code></pre><p><strong>15)</strong> For the input file <code>patterns.txt</code>, filter lines containing three or more occurrences of <code>ar</code>. For such lines, replace the third from last occurrence of <code>ar</code> with <code>X</code>.<pre><code class=language-bash>$ awk ##### add your solution here
par car tX far Cart
pXt cart mart
</code></pre><p><strong>16)</strong> Surround all whole words with <code>()</code>. Additionally, if the whole word is <code>imp</code> or <code>ant</code>, delete them.<pre><code class=language-bash>$ words='tiger imp goat eagle ant important'
$ echo "$words" | awk ##### add your solution here
(tiger) () (goat) (eagle) () (important)
</code></pre><p><strong>17)</strong> For the input file <code>patterns.txt</code>, display lines containing <code>car</code> but not as a whole word. For example, <code>scared-cat</code> and <code>car care</code> should match but not <code>far car park</code>.<pre><code class=language-bash>$ awk ##### add your solution here
scar
care
a huge discarded pile of books
scare
part cart mart
</code></pre><p><strong>18)</strong> Will the pattern <code>^a\w+([0-9]+:fig)?</code> match the same characters for the input <code>apple42:banana314</code> and <code>apple42:fig100</code>? If not, why not?<p><strong>19)</strong> For the input file <code>patterns.txt</code>, display lines starting with <code>4</code> or <code>-</code> or <code>u</code> or <code>sub</code> or <code>care</code>.<pre><code class=language-bash>$ awk ##### add your solution here
care
4*5]
-handy
subtle sequoia
unhand
</code></pre><p><strong>20)</strong> Replace sequences made up of words separated by <code>:</code> or <code>.</code> by the first word of the sequence. Such sequences will end when <code>:</code> or <code>.</code> is not followed by a word character.<pre><code class=language-bash>$ ip='wow:Good:2_two.five: hi-2 bye kite.777:water.'
$ echo "$ip" | awk ##### add your solution here
wow hi-2 bye kite
</code></pre><p><strong>21)</strong> Replace sequences made up of words separated by <code>:</code> or <code>.</code> by the last word of the sequence. Such sequences will end when <code>:</code> or <code>.</code> is not followed by a word character.<pre><code class=language-bash>$ ip='wow:Good:2_two.five: hi-2 bye kite.777:water.'
$ echo "$ip" | awk ##### add your solution here
five hi-2 bye water
</code></pre><p><strong>22)</strong> Replace all whole words with <code>X</code> unless it is preceded by a <code>(</code> character.<pre><code class=language-bash>$ s='guava (apple) berry) apple (mango) (grape'
$ echo "$s" | awk ##### add your solution here
X (apple) X) X (mango) (grape
</code></pre><p><strong>23)</strong> Surround whole words with <code>[]</code> only if they are followed by <code>:</code> or <code>,</code> or <code>-</code>.<pre><code class=language-bash>$ ip='Poke,on=-=so_good:ink.to/is(vast)ever2-sit'
$ echo "$ip" | awk ##### add your solution here
[Poke],on=-=[so_good]:ink.to/is(vast)[ever2]-sit
</code></pre><p><strong>24)</strong> The <code>fields.txt</code> file has fields separated by the <code>:</code> character. Delete <code>:</code> and the last field if there is a digit character anywhere before the last field.<pre><code class=language-bash>$ cat fields.txt
42:cat
twelve:a2b
we:be:he:0:a:b:bother
apple:banana-42:cherry:
dragon:unicorn:centaur

$ awk ##### add your solution here
42
twelve:a2b
we:be:he:0:a:b
apple:banana-42:cherry
dragon:unicorn:centaur
</code></pre><p><strong>25)</strong> Can you use a character other than <code>/</code> as the regexp delimiter? If not, are there ways to construct a regexp that do not require the <code>/</code> character to be escaped for literal matching?<p><strong>26)</strong> For the input file <code>patterns.txt</code>, surround all hexadecimal sequences with a minimum of four characters with <code>[]</code>. Match <code>0x</code> as an optional prefix, but shouldn't be counted for determining the length. Match the characters case insensitively, and the sequences shouldn't be surrounded by other word characters. Display only the modified lines.<pre><code class=language-bash>$ awk ##### add your solution here
"should not match [0XdeadBEEF]"
Hi42Bye nice1423 [bad42]
took 0xbad 22 [0x0ff1ce]
eqn2 = pressure*3+42/5-[14256]
</code></pre></main><nav aria-label="Page navigation"class=nav-wrapper><a aria-label="Previous chapter"class="mobile-nav-chapters previous"title="Previous chapter"aria-keyshortcuts=Left href=awk-introduction.html rel=prev> <i class="fa fa-angle-left"></i> </a><a aria-label="Next chapter"class="mobile-nav-chapters next"title="Next chapter"aria-keyshortcuts=Right href=field-separators.html rel=next> <i class="fa fa-angle-right"></i> </a><div style="clear: both"></div></nav></div></div><nav aria-label="Page navigation"class=nav-wide-wrapper><a aria-label="Previous chapter"class="nav-chapters previous"title="Previous chapter"aria-keyshortcuts=Left href=awk-introduction.html rel=prev> <i class="fa fa-angle-left"></i> </a><a aria-label="Next chapter"class="nav-chapters next"title="Next chapter"aria-keyshortcuts=Right href=field-separators.html rel=next> <i class="fa fa-angle-right"></i> </a></nav></div><script>window.playground_copyable = true;</script><script charset=utf-8 src=elasticlunr.min.js></script><script charset=utf-8 src=mark.min.js></script><script charset=utf-8 src=searcher.js></script><script charset=utf-8 src=clipboard.min.js></script><script charset=utf-8 src=highlight.js></script><script charset=utf-8 src=book.js></script><script src=sidebar.js></script>